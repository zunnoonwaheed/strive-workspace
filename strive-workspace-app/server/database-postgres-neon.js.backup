import { neon } from '@neondatabase/serverless';
import bcrypt from 'bcryptjs';

// Get database URL from environment variable (lazy loaded)
let sql = null;

function getSqlClient() {
  if (!sql) {
    const DATABASE_URL = process.env.DATABASE_URL || process.env.POSTGRES_URL;

    if (!DATABASE_URL) {
      throw new Error('DATABASE_URL or POSTGRES_URL environment variable is not set!');
    }

    sql = neon(DATABASE_URL);
  }
  return sql;
}

// Initialize database tables
export const initDatabase = async () => {
  try {
    console.log('ðŸ”„ Initializing database...');
    const sql = getSqlClient();

    // Create conversations table
    await sql`
      CREATE TABLE IF NOT EXISTS conversations (
        id SERIAL PRIMARY KEY,
        session_id TEXT NOT NULL,
        user_message TEXT NOT NULL,
        bot_response TEXT NOT NULL,
        user_email TEXT,
        user_phone TEXT,
        intent_topic TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `;

    // Create admin_users table
    await sql`
      CREATE TABLE IF NOT EXISTS admin_users (
        id SERIAL PRIMARY KEY,
        username TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `;

    // Create sessions table
    await sql`
      CREATE TABLE IF NOT EXISTS sessions (
        id SERIAL PRIMARY KEY,
        session_id TEXT UNIQUE NOT NULL,
        user_email TEXT,
        user_phone TEXT,
        first_message_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_message_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `;

    // Create index on session_id for faster queries
    await sql`
      CREATE INDEX IF NOT EXISTS idx_conversations_session_id
      ON conversations(session_id)
    `;

    await sql`
      CREATE INDEX IF NOT EXISTS idx_conversations_created_at
      ON conversations(created_at DESC)
    `;

    // Check if admin user exists
    const adminUsers = await sql`
      SELECT * FROM admin_users WHERE username = 'admin'
    `;

    if (adminUsers.length === 0) {
      const passwordHash = await bcrypt.hash('admin123', 10);
      await sql`
        INSERT INTO admin_users (username, password_hash)
        VALUES ('admin', ${passwordHash})
      `;
      console.log('âœ… Default admin user created: admin / admin123');
    }

    console.log('âœ… Database initialized successfully');
  } catch (error) {
    console.error('âŒ Database initialization error:', error);
    throw error;
  }
};

// Database helper functions
export const db = {
  // Run a query (INSERT, UPDATE, DELETE)
  run: async (query, params = []) => {
    try {
      const sql = getSqlClient();

      // Replace ? with $1, $2, etc for Postgres
      let paramIndex = 1;
      const pgQuery = query.replace(/\?/g, () => `$${paramIndex++}`);

      // Add RETURNING clause for INSERT queries
      const finalQuery = pgQuery.toUpperCase().includes('INSERT INTO') && !pgQuery.toUpperCase().includes('RETURNING')
        ? pgQuery + ' RETURNING *'
        : pgQuery;

      // Use sql() directly with properly formatted query
      const result = await sql(finalQuery, params);

      return {
        lastID: result[0]?.id,
        changes: result.length || 0
      };
    } catch (error) {
      console.error('Database run error:', error, { query, params });
      throw error;
    }
  },

  // Get a single row
  get: async (query, params = []) => {
    try {
      const sql = getSqlClient();

      // Replace ? with $1, $2, etc for Postgres
      let paramIndex = 1;
      const pgQuery = query.replace(/\?/g, () => `$${paramIndex++}`);

      const result = await sql(pgQuery, params);
      return result[0] || null;
    } catch (error) {
      console.error('Database get error:', error, { query, params });
      throw error;
    }
  },

  // Get all rows
  all: async (query, params = []) => {
    try {
      const sql = getSqlClient();

      // Replace ? with $1, $2, etc for Postgres
      let paramIndex = 1;
      const pgQuery = query.replace(/\?/g, () => `$${paramIndex++}`);

      const result = await sql(pgQuery, params);
      return result;
    } catch (error) {
      console.error('Database all error:', error, { query, params });
      throw error;
    }
  }
};

export default db;
